@page "/"
@using Microsoft.AspNetCore.Components
@using System.Text.Json

<style>
    .table-container table {
        border-collapse: collapse; /* Optional: Collapse the border spacing */
    }

    .table-container th,
    .table-container td {
        border: 1px solid black; /* Add border to table cells */
        padding: 8px; /* Optional: Add padding for better spacing */
    }
</style>


<div style="display: flex; gap: 16px;">
    <h1>Variabile:</h1>
    <input type="number" @bind="@variabile" />
    <h1>Restrictii:</h1>
    <input type="number" @bind="@restrictii" />
    <button @onclick="genereazaTabel">Genereaza matricea</button>
</div>

@if (tabelVisible)
{
    <div style="display: flex; gap:16px;">
        <select @bind="@SelectedMode">
            <option value="max">Max</option>
            <option value="min">Min</option>
        </select>
        <p>f=</p>
        @for (int i = 0; i < functionValues?.Length; i++)
        {
            double row = i;
            double value = functionValues[i]; // Temporary variable
            <input type="number" @bind="value" @oninput="(e) => CustomFunction2(e, (int)row, value)" />
            <p>x @i</p>
            @if (i != functionValues?.Length - 1)
            {
                <p>+</p>
            }
            functionValues[i] = value; // Update the array with the modified value
        }
    </div>
    <div>
        <table>
            <tbody>
                @for (int i = 0; i < matrix?.Length; i++)
                {
                    <tr>
                        @for (int j = 0; j < variabile; j++)
                        {
                            double row = i; // Create a local copy of i
                            double column = j; // Create a local copy of j
                            <td>
                                <input type="number" value="@matrix[(int)row][(int)column]" @oninput="(e) => CustomFunction(e, (int)row, (int)column)" />
                            </td>
                            <td><p>x @j</p></td>
                            @if (j != variabile - 1)
                            {
                                <td>
                                    <p>+</p>
                                </td>
                            }
                        }

                        @if (i < restrictionValues?.Length)
                        {
                            int row = i; // Create a local copy of i
                            <td><p>asd</p></td>
                            <td><input type="number" value="@restrictionValues[i]" @oninput="(e) => CustomFunction3(e, row)" /></td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <button @onclick="OnCheckButtonClicked">Check</button>
    <hr />

    @if (simplexSteps != null)
    {
        <h2>Simplex Algorithm Steps:</h2>
        <div class="table-container">
            @foreach (var step in simplexSteps)
            {
                <div>
                    <h3>Step @step.StepNumber:</h3>
                    <p>Table:</p>
                    <table>
                        <thead>
                            <tr>
                                @for (int i = 0; i < step.TableHeaders.Length; i++)
                                {
                                    <th>@step.TableHeaders[i]</th>
                                }
                            </tr>
                        </thead>
                        <tbody>
                            @for (int i = 0; i < step.TableRows.Length; i++)
                            {
                                <tr>
                                    @for (int j = 0; j < step.TableRows[i].Length; j++)
                                    {
                                        <td>@step.TableRows[i][j]</td>
                                    }
                                </tr>
                            }
                        </tbody>
                    </table>

                    <p>Delta J:</p>
                    <table>
                        <thead>
                            <tr>
                                @for (int i = 0; i < step.DeltaJ.Length; i++)
                                {
                                    <th>@step.DeltaJ[i]</th>
                                }
                            </tr>
                        </thead>
                    </table>

                    @if (step.PivotElement != null)
                    {
                        <p> pivot: @step.PivotElement</p>
                    }
                </div>
                <hr />
            }
        </div>
    }
}

@code
{
    int variabile = 3;
    int restrictii = 3;
    string SelectedMode = "max";
    private bool tabelVisible = false;

    private double[][] matrix;
    private double[] functionValues;
    private double[] restrictionValues;

    private List<SimplexStep> simplexSteps;
    private void genereazaTabel()
    {
        if (tabelVisible)
        {
            tabelVisible = false;
            StateHasChanged();
        }

        matrix = new double[restrictii][];
        for (int i = 0; i < restrictii; i++)
        {
            matrix[i] = new double[variabile];
            for (int j = 0; j < variabile; j++)
            {
                matrix[i][j] = 0;
            }
        }

        functionValues = new double[variabile];
        restrictionValues = new double[restrictii];

        tabelVisible = true;
        StateHasChanged();
    }

    private void OnCheckButtonClicked()
    {
        // Perform simplex algorithm calculations and store the steps
        simplexSteps = PerformSimplexAlgorithm();
    }

    private void CustomFunction(ChangeEventArgs e, int i, int j)
    {
        int value;
        if (int.TryParse(e.Value.ToString(), out value))
        {
            matrix[i][j] = value;
        }
    }

    private void CustomFunction2(ChangeEventArgs e, int row, double value)
    {
        if (double.TryParse(e.Value.ToString(), out double newValue))
        {
            value = newValue; // Update the temporary variable with the modified value
        }

        functionValues[row] = value; // Update the array with the modified value
    }

    private void CustomFunction3(ChangeEventArgs e, int i)
    {
        int value;
        if (int.TryParse(e.Value.ToString(), out value))
        {
            restrictionValues[i] = value; // Update the array with the modified value
        }
    }

    private List<SimplexStep> PerformSimplexAlgorithm()
    {
        Console.WriteLine("start");
        var steps = new List<SimplexStep>();

        // Validate sizes of arrays
        if (matrix.Length != restrictii || functionValues.Length != variabile || restrictionValues.Length != restrictii)
        {
            return steps; // Return empty steps list if sizes are inconsistent
        }

        // Step 0: Initial table setup
        var table = new double[restrictii][];
        var indexOfOne = variabile;
        for (int i = 0; i < restrictii; i++)
        {
            table[i] = new double[variabile + restrictii];
            for (int j = 0; j < variabile + restrictii; j++)
            {
                if (j < variabile)
                {
                    table[i][j] = matrix[i][j];
                }
                else
                {
                    if (j == indexOfOne)
                    {
                        table[i][j] = 1;
                    }
                    else
                    {
                        table[i][j] = 0;
                    }

                }
            }
            indexOfOne++;
        } //this is correct


        var xb = (double[])restrictionValues.Clone();

        //calculam baza si coef bazei
        double[] baza = new double[restrictii];
        var primaBaza = variabile;
        for (int i = 0; i < restrictii; i++)
        {
            baza[i] = primaBaza;
            primaBaza++;
        }
        Console.WriteLine($"baza: {JsonSerializer.Serialize(baza)}");
        double[] coefBazeiInit = new double[restrictii + variabile];
        for (int i = 0; i < restrictii + variabile; i++)
        {
            if (i < restrictii)
            {
                coefBazeiInit[i] = functionValues[i];
            }
            else
            {
                coefBazeiInit[i] = 0;
            }
        }
        Console.WriteLine($"Coef bazei init: {JsonSerializer.Serialize(coefBazeiInit)}");
        double[] coefBazei = baza.Select(i => coefBazeiInit[(int)i]).ToArray();
        Console.WriteLine($"Coef bazei calculat : {JsonSerializer.Serialize(coefBazei)}");
        var zj = CalculateZj(table, coefBazei);
        Console.WriteLine($"ZJ CALCULAT: {JsonSerializer.Serialize(zj)}");
        var deltaj = CalculateDeltaJ(coefBazeiInit, zj);
        Console.WriteLine($"dj CALCULAT: {JsonSerializer.Serialize(CalculateDeltaJ(coefBazeiInit, zj))}");
        //check if the problem is optimal
        int iterations = 0;
        while (true)
        {
            Console.WriteLine($"optim:{IsOptimal(deltaj)}");
            if (IsOptimal(deltaj)) break;
            Console.WriteLine($"iteratia {iterations}");
            var pivotElementColumn = FindEnteringColumn(deltaj);
            Console.WriteLine(JsonSerializer.Serialize(table));
            var pivotElementRow = FindExitingColumn(xb, table, pivotElementColumn);
            Console.WriteLine(JsonSerializer.Serialize(table));
            var pivotElement = table[pivotElementRow][pivotElementColumn];
            Console.WriteLine($"pivot: {pivotElement}");
            Console.WriteLine(JsonSerializer.Serialize(table));
            Console.WriteLine($"xb inainte de hau hau:{JsonSerializer.Serialize(xb)}");
            var tableCopy = (double[][])table.Clone();
            steps.Add(new SimplexStep
                {
                    StepNumber = iterations,
                    TableHeaders = GenerateTableHeaders(),
                    TableRows = GenerateTableRows(tableCopy),
                    DeltaJ = deltaj.Select(d => d.ToString()).ToArray(),
                    PivotElement = tableCopy[pivotElementRow][pivotElementColumn].ToString(),
                    XB = xb.Select(x => x.ToString()).ToArray(),
                    ZJ = zj.Select(z => z.ToString()).ToArray(),
                    CB = coefBazei.Select(c => c.ToString()).ToArray(),
                    Baza = baza.Select(b => b.ToString()).ToArray()
                });
            PerformTableTransformation(table, pivotElementColumn, pivotElementRow, xb);
            // calculam baza si coef bazei
            Console.WriteLine($"xb dupa de hau hau:{JsonSerializer.Serialize(xb)}");
            baza[pivotElementRow] = pivotElementColumn;
            Console.WriteLine($"baza: {JsonSerializer.Serialize(baza)}");
            coefBazei = baza.Select(i => coefBazeiInit[(int)i]).ToArray();
            Console.WriteLine($"Coef bazei calculat : {JsonSerializer.Serialize(coefBazei)}");
            zj = CalculateZj(table, coefBazei);
            Console.WriteLine($"ZJ CALCULAT: {JsonSerializer.Serialize(zj)}");
            deltaj = CalculateDeltaJ(coefBazeiInit, zj);
            Console.WriteLine($"dj CALCULAT: {JsonSerializer.Serialize(CalculateDeltaJ(coefBazeiInit, zj))}");
            iterations++;
        }
        steps.Add(new SimplexStep
            {
                StepNumber = iterations,
                TableHeaders = GenerateTableHeaders(),
                TableRows = GenerateTableRows(table),
                DeltaJ = deltaj.Select(d => d.ToString()).ToArray(),
                PivotElement = "Optimal",
            });

        return steps;
    }

    private void PerformTableTransformation(double[][] table, int columnIndexOfPivot, int rowIndexOfPivot, double[] xb)
    {
        var pivotElement = table[rowIndexOfPivot][columnIndexOfPivot];
        var pivotRow = table[rowIndexOfPivot];

        // Divide pivot row by pivot element
        xb[rowIndexOfPivot] /= pivotElement;
        for (int i = 0; i < pivotRow.Length; i++)
        {
            pivotRow[i] /= pivotElement;
        }
        // Subtract pivot row from all other rows
        for (int i = 0; i < table.Length; i++)
        {
            if (i == rowIndexOfPivot)
                continue;
            var row = table[i];
            var rowMultiplier = row[columnIndexOfPivot];
            for (int j = 0; j < row.Length; j++)
            {
                row[j] -= rowMultiplier * pivotRow[j];
            }
            xb[i] -= rowMultiplier * xb[rowIndexOfPivot];
        }
    }


    private int FindEnteringColumn(double[] deltaJ)
    {
        Console.WriteLine(Array.IndexOf(deltaJ, deltaJ.Max()));
        return Array.IndexOf(deltaJ, deltaJ.Max());
    }

    private int FindExitingColumn(double[] xb, double[][] table, int enteringColumn)
    {
        // we create a copy of the table array
        var tableCopy = new double[table.Length][];
        for (int i = 0; i < table.Length; i++)
        {
            tableCopy[i] = new double[table[i].Length];
            for (int j = 0; j < table[i].Length; j++)
            {
                tableCopy[i][j] = table[i][j];
            }
        }
        Console.WriteLine($"copy:{JsonSerializer.Serialize(tableCopy)}");
        // we calculate the ratios
        var ratios = new double[tableCopy.Length];
        for (int i = 0; i < xb.Length; i++)
        {
            ratios[i] = xb[i] / tableCopy[i][enteringColumn];
        }
        Console.WriteLine($"ratios:{JsonSerializer.Serialize(ratios)}");

        var indexOfMinRatio = Array.IndexOf(ratios, ratios.Min());

        Console.WriteLine($"minRatio:{ratios[indexOfMinRatio]}");
        Console.WriteLine($"minRatioIndex:{indexOfMinRatio}");
        return indexOfMinRatio;
    }

    private bool IsOptimal(double[] deltaJ)
    {
        return deltaJ.All(d => d <= 0);
    }

    private double[] CalculateDeltaJ(double[] cbInit, double[] zj)
    {
        var deltaJ = new double[variabile + restrictii];
        for (int j = 0; j < variabile + restrictii; j++)
        {
            deltaJ[j] = cbInit[j] - zj[j];
        }
        Console.WriteLine("dj");
        Console.WriteLine(JsonSerializer.Serialize(deltaJ));
        return deltaJ;
    }

    private double[] CalculateZj(double[][] table, double[] cb)
    {
        var zj = new double[variabile + restrictii];
        for (int j = 0; j < variabile + restrictii; j++)
        {
            for (int i = 0; i < restrictii; i++)
            {
                zj[j] += cb[i] * table[i][j];
            }
        }
        return zj;
    }

    private string[] GenerateTableHeaders()
    {
        var headers = new List<string>();

        for (int j = 0; j < variabile + restrictii; j++)
        {
            if (j < variabile)
            {
                headers.Add($"x{j}");
            }
            else
            {
                headers.Add($"s{j - variabile + 1}");
            }
        }

        return headers.ToArray();
    }

    private string[][] GenerateTableRows(double[][] table)
    {
        var rows = new List<string[]>();

        for (int i = 0; i < restrictii; i++)
        {
            var row = new List<string>();
            for (int j = 0; j < variabile + restrictii; j++)
            {
                row.Add(table[i][j].ToString());
            }
            rows.Add(row.ToArray());
        }

        return rows.ToArray();
    }
    public class SimplexStep
    {
        public int StepNumber { get; set; }
        public string[] TableHeaders { get; set; }
        public string[][] TableRows { get; set; }
        public string[] DeltaJ { get; set; }
        public string[] CB { get; set; }
        public string[] ZJ { get; set; }
        public string[] XB { get; set; }
        public string[] Baza { get; set; }
        public string PivotElement { get; set; }
    }
}