@page "/"
@using Microsoft.AspNetCore.Components

<div style="display: flex; gap: 16px;">
    <h1>Variabile:</h1>
    <input type="number" @bind="@variabile" />
    <h1>Restrictii:</h1>
    <input type="number" @bind="@restrictii" />
    <button @onclick="genereazaTabel">Genereaza matricea</button>
</div>

@if (tabelVisible)
{
    <div style="display: flex; gap:16px;">
        <select @bind="@SelectedMode">
            <option value="max">Max</option>
            <option value="min">Min</option>
        </select>
        <p>f=</p>
        @for (int i = 0; i < functionValues?.Length; i++)
        {
            double row = i;
            double value = functionValues[i]; // Temporary variable
            <input type="number" @bind="value" @oninput="(e) => CustomFunction2(e, (int)row, value)" />
            <p>x @i</p>
            @if (i != functionValues?.Length - 1)
            {
                <p>+</p>
            }
            functionValues[i] = value; // Update the array with the modified value
        }
    </div>
    <div>
        <table>
            <tbody>
                @for (int i = 0; i < matrix?.Length; i++)
                {
                    <tr>
                        @for (int j = 0; j < variabile; j++)
                        {
                            double row = i; // Create a local copy of i
                            double column = j; // Create a local copy of j
                            <td>
                                <input type="number" value="@matrix[(int)row][(int)column]" @oninput="(e) => CustomFunction(e, (int)row, (int)column)" />
                            </td>
                            <td><p>x @j</p></td>
                            @if (j != variabile - 1)
                            {
                                <td>
                                    <p>+</p>
                                </td>
                            }
                        }

                        @if (i < restrictionValues?.Length)
                        {
                            int row = i; // Create a local copy of i
                            <td><p>asd</p></td>
                            <td><input type="number" value="@restrictionValues[i]" @oninput="(e) => CustomFunction3(e, row)" /></td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <button @onclick="OnCheckButtonClicked">Check</button>
}

@code
{
    int variabile = 3;
    int restrictii = 3;
    string SelectedMode = "max";
    private bool tabelVisible = false;

    private double[][] matrix;
    private double[] functionValues;
    private double[] restrictionValues;

    private void genereazaTabel()
    {
        if (tabelVisible) tabelVisible = false;
        StateHasChanged();

        matrix = new double[restrictii][];
        for (int i = 0; i < restrictii; i++)
        {
            matrix[i] = new double[variabile];
            for (int j = 0; j < variabile; j++)
            {
                matrix[i][j] = 0;
            }
        }

        functionValues = new double[variabile];
        for (int i = 0; i < variabile; i++)
        {
            functionValues[i] = 0;
        }

        restrictionValues = new double[restrictii];
        for (int i = 0; i < restrictii; i++)
        {
            restrictionValues[i] = 0;
        }

        tabelVisible = true;
        StateHasChanged();
    }

    private void OnCheckButtonClicked()
    {
        SimplexSolver solver = new SimplexSolver(matrix, functionValues, restrictionValues, SelectedMode);
        solver.Solve();
    }

    private void CustomFunction(ChangeEventArgs e, int i, int j)
    {
        int value;
        if (int.TryParse(e.Value.ToString(), out value))
        {
            matrix[i][j] = value;
        }

    }

    private void CustomFunction2(ChangeEventArgs e, int row, double value)
    {
        if (double.TryParse(e.Value.ToString(), out double newValue))
        {
            value = newValue; // Update the temporary variable with the modified value
        }

        functionValues[row] = value; // Update the array with the modified value
    }

    private void CustomFunction3(ChangeEventArgs e, int i)
    {
        int value;
        if (int.TryParse(e.Value.ToString(), out value))
        {
            restrictionValues[i] = value; // Update the array with the modified value
        }

    }

    public class SimplexSolver
    {
        private double[][] matrix;
        private double[] functionValues;
        private double[] restrictionValues;
        private string selectedMode;

        public SimplexSolver(double[][] matrix, double[] functionValues, double[] restrictionValues, string selectedMode)
        {
            this.matrix = matrix;
            this.functionValues = functionValues;
            this.restrictionValues = restrictionValues;
            this.selectedMode = selectedMode;
        }

        public void Solve()
        {
            int var_principale = matrix[0].Length;
            double[] F = functionValues;
            double[][] Conditii = matrix;
            double[] b = restrictionValues;

            int numRestrictions = Conditii.Length;
            int numVariables = var_principale;

            double[][] A = new double[numRestrictions][];
            for (int i = 0; i < numRestrictions; i++)
            {
                A[i] = new double[numVariables + numRestrictions + 1];
                for (int j = 0; j < numVariables; j++)
                {
                    A[i][j] = Conditii[i][j];
                }
                A[i][numVariables + i] = 1;
                A[i][A[i].Length - 1] = b[i];
            }

            double[] Cj = new double[A[0].Length];
            Cj[0] = selectedMode == "max" ? -1 * F[0] : F[0];
            for (int i = 0; i < var_principale; i++)
            {
                Cj[i + 1] = selectedMode == "max" ? -1 * F[i] : F[i];
            }

            int[] VS = new int[A.Length];
            for (int i = 0; i < VS.Length; i++)
            {
                VS[i] = numVariables + i + 1;
            }

            bool RUN = true;
            while (RUN)
            {
                double[] Zj = CalculateZj(Cj, A, VS);
                double[] deltaJ = CalculateDeltaJ(Cj, Zj);

                if (AnyPositive(deltaJ))
                {
                    Console.WriteLine("Testul de optimalitate nu este valid");
                    Console.WriteLine("Trecem la urmatoarea iteratie");
                    Console.Write("Vechea baza: ");
                    double[] doubleVS = Array.ConvertAll(VS, x => (double)x);
                    PrintArray(doubleVS);
                    

                    int col_pivot = FindEnteringVariable(deltaJ);
                    Console.WriteLine("\nAplicam criteriul de intrare in baza C↓B");
                    Console.WriteLine($"max(deltaj>0) = {deltaJ[col_pivot]} care corespunde vectorului a{col_pivot + 1}");
                    Console.WriteLine($"Deci a{col_pivot + 1}↓B");

                    Console.WriteLine("\nAplicam criteriul de iesire din baza C↑B");
                    int rand_pivot = FindLeavingVariable(A, col_pivot);
                    Console.WriteLine($"min{{XB/ak}} = {CalculateMinRatio(A, rand_pivot)} care corespunde vectorului a{VS[rand_pivot]}");
                    Console.WriteLine($"Deci a{VS[rand_pivot]}↑B");

                    VS[rand_pivot] = col_pivot + 1;
                    Console.WriteLine($"\nNoua baza B = {{a{VS[0]}, a{VS[1]}, a{VS[2]}}} (exemplu pentru 3 variabile)");

                    double pivot = A[rand_pivot][col_pivot];

                    A[rand_pivot] = DivideArrayByScalar(A[rand_pivot], pivot);

                    for (int i = 0; i < A.Length; i++)
                    {
                        if (i != rand_pivot)
                        {
                            double[] temp = MultiplyArrayByScalar(A[rand_pivot], A[i][col_pivot]);
                            A[i] = SubtractArrays(A[i], temp);
                        }
                    }
                    Console.WriteLine("\nNoua matrice A:");
                    PrintMatrix(A);

                    Console.WriteLine("\nNoul vector Cj:");
                    PrintArray(Cj);
                }
                else
                {
                    RUN = false;
                    Console.WriteLine("\nSolutia optima a fost atinsa!");
                    Console.WriteLine("Tabelul final:");

                    double[] Xb = new double[A.Length];
                    double[] X = new double[A[0].Length - 1];
                    double fx = selectedMode == "max" ? CalculateFx(Zj, Xb) : -1 * CalculateFx(Zj, Xb);

                    for (int i = 0; i < VS.Length; i++)
                    {
                        X[VS[i]] = Xb[i];
                    }

                    Console.WriteLine("X = ");
                    for (int i = 0; i < X.Length; i++)
                    {
                        Console.WriteLine($"x{i + 1} = {X[i]}");
                    }
                }
            }
        }

        private double[] CalculateZj(double[] Cj, double[][] A, int[] VS)
        {
            double[] Zj = new double[Cj.Length];

            for (int j = 0; j < Cj.Length; j++)
            {
                for (int i = 0; i < VS.Length; i++)
                {
                    Zj[j] += Cj[VS[i] - 1] * A[i][j];
                }
            }

            return Zj;
        }

        private double[] CalculateDeltaJ(double[] Cj, double[] Zj)
        {
            double[] deltaJ = new double[Cj.Length];

            for (int j = 0; j < Cj.Length; j++)
            {
                deltaJ[j] = Cj[j] - Zj[j];
            }

            return deltaJ;
        }

        private bool AnyPositive(double[] array)
        {
            foreach (var value in array)
            {
                if (value > 0)
                    return true;
            }
            return false;
        }

        private int FindEnteringVariable(double[] deltaJ)
        {
            double max = deltaJ[0];
            int col_pivot = 0;

            for (int j = 1; j < deltaJ.Length; j++)
            {
                if (deltaJ[j] > max)
                {
                    max = deltaJ[j];
                    col_pivot = j;
                }
            }

            return col_pivot;
        }

        private int FindLeavingVariable(double[][] A, int col_pivot)
        {
            int minRatioIndex = -1;
            double minRatio = double.MaxValue;

            for (int i = 0; i < A.Length; i++)
            {
                if (A[i][col_pivot] > 0)
                {
                    double ratio = A[i][A[i].Length - 1] / A[i][col_pivot];
                    if (ratio < minRatio)
                    {
                        minRatio = ratio;
                        minRatioIndex = i;
                    }
                }
            }

            return minRatioIndex;
        }

        private double CalculateMinRatio(double[][] A, int row_pivot)
        {
            double minRatio = double.MaxValue;

            for (int j = 0; j < A[row_pivot].Length - 1; j++)
            {
                if (A[row_pivot][j] > 0)
                {
                    double ratio = A[row_pivot][A[row_pivot].Length - 1] / A[row_pivot][j];
                    if (ratio < minRatio)
                    {
                        minRatio = ratio;
                    }
                }
            }

            return minRatio;
        }

        private double[] DivideArrayByScalar(double[] array, double scalar)
        {
            double[] result = new double[array.Length];

            for (int i = 0; i < array.Length; i++)
            {
                result[i] = array[i] / scalar;
            }

            return result;
        }

        private double[] MultiplyArrayByScalar(double[] array, double scalar)
        {
            double[] result = new double[array.Length];

            for (int i = 0; i < array.Length; i++)
            {
                result[i] = array[i] * scalar;
            }

            return result;
        }

        private double[] SubtractArrays(double[] array1, double[] array2)
        {
            double[] result = new double[array1.Length];

            for (int i = 0; i < array1.Length; i++)
            {
                result[i] = array1[i] - array2[i];
            }

            return result;
        }

        private double CalculateFx(double[] Zj, double[] Xb)
        {
            double fx = 0;

            for (int i = 0; i < Xb.Length; i++)
            {
                fx += Zj[i] * Xb[i];
            }

            return fx;
        }

        private void PrintArray(double[] array)
        {
            Console.Write("[ ");
            foreach (var value in array)
            {
                Console.Write(value + " ");
            }
            Console.WriteLine("]");
        }

        private void PrintMatrix(double[][] matrix)
        {
            for (int i = 0; i < matrix.Length; i++)
            {
                for (int j = 0; j < matrix[i].Length; j++)
                {
                    Console.Write(matrix[i][j] + " ");
                }
                Console.WriteLine();
            }
        }
    }


}
