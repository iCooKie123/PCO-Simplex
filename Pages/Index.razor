@page "/"
@using Microsoft.AspNetCore.Components
@using System.Text.Json

<div style="display: flex; gap: 16px;">
    <h1>Variabile:</h1>
    <input type="number" @bind="@variabile" />
    <h1>Restrictii:</h1>
    <input type="number" @bind="@restrictii" />
    <button @onclick="genereazaTabel">Genereaza matricea</button>
</div>

@if (tabelVisible)
{
    <div style="display: flex; gap:16px;">
        <select @bind="@SelectedMode">
            <option value="max">Max</option>
            <option value="min">Min</option>
        </select>
        <p>f=</p>
        @for (int i = 0; i < functionValues?.Length; i++)
        {
            double row = i;
            double value = functionValues[i]; // Temporary variable
            <input type="number" @bind="value" @oninput="(e) => CustomFunction2(e, (int)row, value)" />
            <p>x @i</p>
            @if (i != functionValues?.Length - 1)
            {
                <p>+</p>
            }
            functionValues[i] = value; // Update the array with the modified value
        }
    </div>
    <div>
        <table>
            <tbody>
                @for (int i = 0; i < matrix?.Length; i++)
                {
                    <tr>
                        @for (int j = 0; j < variabile; j++)
                        {
                            double row = i; // Create a local copy of i
                            double column = j; // Create a local copy of j
                            <td>
                                <input type="number" value="@matrix[(int)row][(int)column]" @oninput="(e) => CustomFunction(e, (int)row, (int)column)" />
                            </td>
                            <td><p>x @j</p></td>
                            @if (j != variabile - 1)
                            {
                                <td>
                                    <p>+</p>
                                </td>
                            }
                        }

                        @if (i < restrictionValues?.Length)
                        {
                            int row = i; // Create a local copy of i
                            <td><p>asd</p></td>
                            <td><input type="number" value="@restrictionValues[i]" @oninput="(e) => CustomFunction3(e, row)" /></td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <button @onclick="OnCheckButtonClicked">Check</button>
    <hr />

    @if (simplexSteps != null)
    {
        <h2>Simplex Algorithm Steps:</h2>
        @foreach (var step in simplexSteps)
        {
            <div>
                <h3>Step @step.StepNumber:</h3>
                <p>Table:</p>
                <table>
                    <thead>
                        <tr>
                            @for (int i = 0; i < step.TableHeaders.Length; i++)
                            {
                                <th>@step.TableHeaders[i]</th>
                            }
                        </tr>
                    </thead>
                    <tbody>
                        @for (int i = 0; i < step.TableRows.Length; i++)
                        {
                            <tr>
                                @for (int j = 0; j < step.TableRows[i].Length; j++)
                                {
                                    <td>@step.TableRows[i][j]</td>
                                }
                            </tr>
                        }
                    </tbody>
                </table>

                <p>Delta J:</p>
                <table>
                    <thead>
                        <tr>
                            @for (int i = 0; i < step.DeltaJ.Length; i++)
                            {
                                <th>@step.DeltaJ[i]</th>
                            }
                        </tr>
                    </thead>
                </table>

                <p>CB:</p>
                <table>
                    <thead>
                        <tr>
                            @for (int i = 0; i < step.CB.Length; i++)
                            {
                                <th>@step.CB[i]</th>
                            }
                        </tr>
                    </thead>
                </table>
            </div>
            <hr />
        }
    }
}

@code
{
    int variabile = 3;
    int restrictii = 3;
    string SelectedMode = "max";
    private bool tabelVisible = false;

    private double[][] matrix;
    private double[] functionValues;
    private double[] restrictionValues;

    private List<SimplexStep> simplexSteps;
    private void genereazaTabel()
    {
        if (tabelVisible)
        {
            tabelVisible = false;
            StateHasChanged();
        }

        matrix = new double[restrictii][];
        for (int i = 0; i < restrictii; i++)
        {
            matrix[i] = new double[variabile];
            for (int j = 0; j < variabile; j++)
            {
                matrix[i][j] = 0;
            }
        }

        functionValues = new double[variabile];
        restrictionValues = new double[restrictii];

        tabelVisible = true;
        StateHasChanged();
    }

    private void OnCheckButtonClicked()
    {
    // Perform simplex algorithm calculations and store the steps
        simplexSteps = PerformSimplexAlgorithm();
    }

    private void CustomFunction(ChangeEventArgs e, int i, int j)
    {
        int value;
        if (int.TryParse(e.Value.ToString(), out value))
        {
            matrix[i][j] = value;
        }
    }

    private void CustomFunction2(ChangeEventArgs e, int row, double value)
    {
        if (double.TryParse(e.Value.ToString(), out double newValue))
        {
            value = newValue; // Update the temporary variable with the modified value
        }

        functionValues[row] = value; // Update the array with the modified value
    }

    private void CustomFunction3(ChangeEventArgs e, int i)
    {
        int value;
        if (int.TryParse(e.Value.ToString(), out value))
        {
            restrictionValues[i] = value; // Update the array with the modified value
        }
    }

    private List<SimplexStep> PerformSimplexAlgorithm()
    {
        var steps = new List<SimplexStep>();

        // Validate sizes of arrays
        if (matrix.Length != restrictii || functionValues.Length != variabile || restrictionValues.Length != restrictii)
        {
            return steps; // Return empty steps list if sizes are inconsistent
        }

        // Step 0: Initial table setup
        var table = new double[restrictii + 1][];
        for (int i = 0; i <= restrictii; i++)
        {
            table[i] = new double[variabile + restrictii];
            for (int j = 0; j < variabile + restrictii; j++)
            {
                if (i < restrictii && j < variabile)
                    table[i][j] = matrix[i][j];
                else if (i < restrictii && j >= variabile && j < variabile + restrictii)
                    table[i][j] = (j - variabile == i) ? 1 : 0;
                else if (i == restrictii && j < variabile)
                    table[i][j] = functionValues[j];
                else if (i == restrictii && j >= variabile && j < variabile + restrictii)
                    table[i][j] = (j - variabile == i) ? 1 : 0;
            }
        }

        int indexOfSecundary=variabile;
        // Step 0: Calculate CB
        var CbInitial = new double[variabile+restrictii];
        for (int i = 0; i < variabile+restrictii; i++)
        {
            if(i<variabile)
                CbInitial[i] = functionValues[i];
            else
                CbInitial[i] = 0;
        }

        //step 0 : Calculate Zj
        var zj = new double[variabile + restrictii];
        for(int i =0; i< variabile + restrictii; i++)
        {
            double sum = 0;
                for(int j = indexOfSecundary; j< restrictii; j++)
            {
                sum += table[j][i] * CbInitial[j];
            }
                zj[i] = sum;
        }
        // Step 0: Calculate DeltaJ
        var deltaJ = new double[variabile + restrictii];
        for (int j = 0; j < variabile + restrictii; j++)
        {
            Console.WriteLine($"cb:{CbInitial[j]} ; zj:{zj[j]}");
            deltaJ[j] = CbInitial[j] - zj[j];
        }


    // Step 0: Add initial step to the list
        steps.Add(new SimplexStep
        {
            StepNumber = 0,
            TableHeaders = GenerateTableHeaders(),
            TableRows = GenerateTableRows(table),
            DeltaJ = deltaJ.Select(d => d.ToString()).ToArray(),
            CB = CbInitial.Select(c => c.ToString()).ToArray()
        });

        Console.WriteLine("initial");
    // // Step 1: Find pivot column
    //     int pivotColumnIndex = Array.IndexOf(deltaJ, deltaJ.Max());
    //
    //     while (deltaJ[pivotColumnIndex] > 0)
    //     {
    // // Step 2: Find pivot row
    //         var ratios = new List<double>();
    //         for (int i = 0; i < restrictii; i++)
    //         {
    //             if (table[i][pivotColumnIndex] > 0)
    //                 ratios.Add(table[i][variabile + restrictii] / table[i][pivotColumnIndex]);
    //             else
    //                 ratios.Add(double.PositiveInfinity);
    //         }
    //         int pivotRowIndex = ratios.IndexOf(ratios.Min());
    //         Console.WriteLine(
    //         "test");
    // // Step 3: Update pivot row
    //         double pivotValue = table[pivotRowIndex][pivotColumnIndex];
    //         for (int j = 0; j <= variabile + restrictii; j++)
    //         {
    //             table[pivotRowIndex][j] /= pivotValue;
    //         }
    //
    // // Step 4: Update other rows
    //         for (int i = 0; i <= restrictii; i++)
    //         {
    //             if (i != pivotRowIndex)
    //             {
    //                 double factor = table[i][pivotColumnIndex];
    //                 for (int j = 0; j <= variabile + restrictii; j++)
    //                 {
    //                     table[i][j] -= factor * table[pivotRowIndex][j];
    //                 }
    //             }
    //         }
    //
    // // Step 5: Update CB and DeltaJ
    //         for (int i = 0; i < variabile + restrictii; i++)
    //         {
    //             double sum = 0;
    //             for (int j = 0; j < restrictii; j++)
    //             {
    //                 sum += table[j][i] * cb[j];
    //             }
    //             deltaJ[i] = cb[i] - sum;
    //         }
    //
    // // Step 6: Add current step to the list
    //         steps.Add(new SimplexStep
    //         {
    //             StepNumber = steps.Count,
    //             TableHeaders = GenerateTableHeaders(),
    //             TableRows = GenerateTableRows(table),
    //             DeltaJ = deltaJ.Select(d => d.ToString()).ToArray(),
    //             CB = cb.Select(c => c.ToString()).ToArray()
    //         });
    //
    // // Step 7: Find next pivot column
    //         pivotColumnIndex = Array.IndexOf(deltaJ, deltaJ.Max());
    //     }

        return steps;
    }

    private string[] GenerateTableHeaders()
    {
        var headers = new List<string>();

        for (int j = 0; j < variabile + restrictii; j++)
        {
            if (j < variabile)
            {
                headers.Add($"x{j}");
            }
            else
            {
                headers.Add($"s{j - variabile + 1}");
            }
        }

        return headers.ToArray();
    }

    private string[][] GenerateTableRows(double[][] table)
    {
        var rows = new List<string[]>();

        for (int i = 0; i < restrictii; i++)
        {
            var row = new List<string>();
            for (int j = 0; j < variabile + restrictii; j++)
            {
                row.Add(table[i][j].ToString());
            }
            rows.Add(row.ToArray());
        }

        return rows.ToArray();
    }
    public class SimplexStep
    {
        public int StepNumber { get; set; }
        public string[] TableHeaders { get; set; }
        public string[][] TableRows { get; set; }
        public string[] DeltaJ { get; set; }
        public string[] CB { get; set; }
    }
}